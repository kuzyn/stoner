#!/usr/bin/env node
const e=require("fs"),t=require("chalk"),n=require("node-emoji"),s=require("fuzzy"),o=require("inquirer"),a=require("node-fetch");o.registerPrompt("autocomplete",require("inquirer-autocomplete-prompt"));const r="https://api.github.com/",l=new a.Headers({"Content-type":"application/json",Authorization:`token ${e.readFileSync(".github-token","utf8").replace("\n","")}`}),u=new Map,i=new Map;let c=null,h=null;process.on("uncaughtException",e=>{console.log(t.red(`${n.get("broken_heart")} something went wrong! it's not you, it's me`)),console.log(t.red(`${n.get("sos")} ${e.message}`)),console.log(t.red(`${n.get("sos")} ${e.stack}`))}),process.on("unhandledRejection",(e,s)=>{console.log(t.yellow(`${n.get("construction")} ${String(e).replace("Error:","Warning:")}`))});const p={milestoneIssues:e=>{const t=[],n={bug:[],feature:[],upkeep:[]};return e.forEach(e=>{t.push({number:e.number,url:e.url,title:e.title,creator:e.user.login,labels:p.labels(e.labels),created_at:e.created_at,updated_at:e.updated_at,closed_at:e.closed_at})}),t.forEach(e=>{e.labels.has("k.bug")&&n.bug.push(e),e.labels.has("k.feature")&&n.feature.push(e),e.labels.has("k.upkeep")&&n.upkeep.push(e)}),n},milestone:e=>({description:e.description,url:e.url,title:e.title,number:e.number,creator:e.creator.login,open_issues:e.open_issues,closed_issues:e.closed_issues,created_at:e.created_at,updated_at:e.updated_at,due_on:e.due_on,closed_at:e.closed_at}),labels:e=>{const t=new Set(["k.feature","k.bug","k.upkeep","x.firebase"]);return e=e.filter(e=>t.has(e.name)),new Set(e.map(e=>e.name))}};console.log("loading..."),o.prompt([{type:"autocomplete",name:"repo",message:"what is the name of the repo?",source:async function(e,t){const n=h||await async function(e,t){let n=[],s=[],o=[];try{s=await async function(e,t){const n=[];let s;try{const n=await a(e+"user/repos",{headers:t});if(s=await n.json(),200!==n.status)throw new Error(`fetchUserRepos ${s.message}`)}catch(e){throw e}return s.forEach(e=>{u.set(e.name,e.url),n.push(e.name)}),n}(e,t),o=await async function(e,t){const n=[];let s=[];try{const o=await a(e+"user/orgs",{headers:t}),r=await o.json();if(200!==o.status)throw new Error(`fetchOrgsRepos ${r.message}`);for(e of s=r.map(e=>e.repos_url)){const s=await a(e,{headers:t}),o=await s.json();o.forEach(e=>{u.set(e.name,e.url),n.push(e.name)})}}catch(e){throw e}return n}(e,t),n=n.concat(s,o)}catch(e){throw e}return h=n.sort(),n.sort()}(r,l);return new Promise(e=>{setTimeout(()=>{const o=s.filter(t||"",n);e(o.map(e=>e.original))},(o=300,Math.floor(Math.random()*Math.floor(o))))});var o},pageSize:5,validate:e=>!!e||"type a repo name"}]).then(async e=>{const t=u.get(e.repo),n=await async function(e,t){const n=[];let s;try{const n=await a(e+"/milestones",{headers:t});if(s=await n.json(),200!==n.status)throw new Error(`fetchMilestoneNames ${s.message}`)}catch(e){throw e}return s.forEach(e=>{i.set(e.title,e.url),n.push(e.title)}),n}(t,l);return c=t,n}).then(e=>o.prompt([{type:"list",name:"milestone",message:"which milestone is it?",choices:e}])).then(async e=>{const t=i.get(e.milestone),n=await async function(e,t){let n;try{const s=await a(e,{headers:t});if(n=await s.json(),200!==s.status)throw new Error(`fetchMilestoneInfo ${n.message}`)}catch(e){throw e}return p.milestone(n)}(t,l);return function(e,t){const n=t.bug,s=t.feature,o=t.upkeep,a=e.due_on?new Date(e.due_on).toUTCString():null,r=e.created_at?new Date(e.created_at).toUTCString():null,l=e.closed_at?new Date(e.closed_at).toUTCString():null;let u=`\n  ---\n\n  ### Milestone [${e.title}](${e.url})\n  _${e.description}_\n\n\n  Due on: ${a}\n  Closed on: ${l}\n  Created on: ${r}\n  Issues nb: ${e.open_issues+e.closed_issues}\n\n  `;return u+="\n",u+=`### Bugs (${n.length})\n`,n.forEach(e=>{u+=`- #${e.number} ${e.title} \`${[...e.labels]}\`\n`}),u+="\n\n",u+=`### Features (${s.length})\n`,s.forEach(e=>{u+=`- #${e.number} ${e.title} \`${[...e.labels]}\`\n`}),u+="\n\n",u+=`### Upkeep (${o.length})\n`,o.forEach(e=>{u+=`- #${e.number} ${e.title} \`${[...e.labels]}\`\n`}),u+="\n\n"}(n,await async function(e,t,n){const s=`${e}/issues?state=all&milestone=${t}`;let o;try{const e=await a(s,{headers:n});if(o=await e.json(),200!==e.status)throw new Error(`fetchMilestoneIssues ${o.message}`)}catch(e){throw e}return p.milestoneIssues(o)}(c,n.number,l))}).then(e=>console.log(e));